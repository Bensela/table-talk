You are the senior web application architect and delivery lead. We are upgrading Dual-Phone Mode only. First, map the current Dual-Phone lifecycle and reconnection behavior, then list exactly what must change to support: (a) join code modal auto-dismiss on successful join, (b) deny third device, (c) Phone A fast resume by scanning the same QR.

Tasks

Identify frontend entry flow for /t/{table_token} and how it decides mode, creates session, and routes.

Locate backend session create logic and dual-phone join logic.

Identify websocket room join logic and the “partner joined” event (or equivalent).

Identify reconnection logic: sessionStorage keys, resume behavior, and any backend validation.

List all changes needed for:

“only 2 participants allowed”

“Phone A role persistence and fast resume on rescan”

“auto-dismiss join-code modal when B joins”

Output

File paths, functions, and exact event names.

A short “as-is” sequence and “to-be” sequence (bulleted).

Acceptance criteria

We know where to implement participant gating, modal dismissal trigger, and reconnect routing.

Phase 1 prompt, updated Dual-Phone contract and state model

Prompt to AI tool
Design the minimal state model and API/event contract to implement the new Dual-Phone behavior. Do not propose rewrites. Keep it additive and feature-flagged.

New requirements
A) Join code modal lifecycle

When Phone A starts Dual session, show join code in a modal.

Modal auto-dismisses when Phone B clicks “Join Dual Phone Session” and is successfully paired.

After paired, deny any other device from joining (Phone C).

B) Phone A resume on rescan

If Phone A disconnects, and later scans the same QR again, it should immediately redirect to the existing open dual session as Phone A.

This must not allow a random new user scanning the QR to hijack Phone A role.

Assumptions to use unless code shows otherwise

You already store session_id in sessionStorage for resume.

You can add a participant token (non-PII) stored in sessionStorage to prove role ownership.

Deliverables

Define dual session states: waiting, paired, ended.

Define participant roles: A and B, enforce max 2.

Define secure “resume as A” rule using a participant_token stored in sessionStorage.

Define websocket events:

dual_waiting_created

dual_partner_joined

dual_join_denied (full room)

dual_session_ended (optional)

Acceptance criteria

Phone C cannot join after paired.

Phone A can resume reliably, and strangers cannot impersonate A.

Phase 2 prompt, schema and constraints for 2-participant gating

Prompt to AI tool
Implement DB changes to support dual pairing, enforce max 2 participants, and enable role-based resume.

Implement

Add or confirm sessions fields:

dual_status: waiting|paired|ended

pairing_code_hash, pairing_expires_at

last_activity_at

Add session_participants table (recommended for correctness and security)
Columns

participant_id UUID PK

session_id UUID FK

role ENUM or VARCHAR: A|B

participant_token_hash TEXT (hash of a random token stored client-side)

created_at, last_seen_at, disconnected_at nullable

Constraints and indexes

Unique(session_id, role) so only one A and one B exist.

Index(session_id) and index(participant_token_hash).

Output

Migrations + rollback migrations.

Updated ORM models.

Acceptance criteria

Database prevents a third participant from being created for the same role.

We can validate a resume request by participant_token_hash.

Phase 3 prompt, backend endpoints and logic, pairing and denial behavior

Prompt to AI tool
Implement minimal backend APIs to support dual creation, join, denial of Phone C, and Phone A resume by scanning QR.

Endpoints

POST /api/sessions (create session)
If mode=dual:

Create session with dual_status=waiting

Generate 4–6 digit join code, store only hash, set pairing_expires_at = now + 10 minutes

Create participant A immediately:

generate a random participant_token (not code)

store participant_token_hash

return participant_id, role=A, and raw participant_token to client once

Return join code (raw only once) to show in modal

Response example

{ session_id, dual_status, pairing_code, pairing_expires_at, participant_id, role, participant_token }

POST /api/sessions/join-dual
Input: restaurant_id, table_token, code
Behavior

Find the most recent session for table_token in dual_status=waiting with pairing_expires_at > now

Validate code hash

Create participant B if role B does not exist

If B already exists or session is paired, return 409 “SESSION_FULL”

If success: set dual_status=paired, return session_id, participant_id, role=B, participant_token

POST /api/sessions/resume-by-qr (new) OR extend existing “lookup” endpoint
Input: restaurant_id, table_token, participant_token
Behavior

Hash participant_token and find active session_participants where token matches

Return session_id and role

This is the key to “Phone A scans QR and resumes instantly” without exposing table-level join to strangers.

Security and abuse controls

Never log raw join codes or participant tokens.

Rate-limit join-dual attempts by table_token and IP.

Return generic errors for invalid code/token.

Output

Controllers, services, validation, unit tests for:

pairing success

denial when already paired

denial for third device

resume by participant token

Acceptance criteria

Phone C receives “SESSION_FULL” once A+B are paired.

Phone A can resume using participant token, not just by scanning.

Phase 4 prompt, websocket events for modal auto-dismiss and session sync

Prompt to AI tool
Update websocket behavior to drive the join-code modal lifecycle and enforce participant authorization.

Implement

Socket join authorization

Client must send session_id + participant_id (or participant_token)

Server validates participant belongs to session

Reject unauthorized joins

Event: dual_partner_joined

When B successfully joins, server emits to session room:

{ session_id, joined_role: "B" }

Phone A listens for this and auto-dismisses the join modal immediately.

Optional event: dual_join_denied

If a device attempts to join after paired, emit or return error response only (API is sufficient).

Output

Websocket handler updates

Frontend event listeners updated

Tests or dev scripts for socket join and event emission

Acceptance criteria

Modal dismisses in real-time on successful join.

Unauthorized listeners cannot subscribe.

Phase 5 prompt, frontend flow changes, modal dialog, join button, and resume routing

Prompt to AI tool
Implement the required frontend UX changes with minimal UI disruption.

Implement

A) Phone A Dual session create flow

User selects Dual-Phone mode and context, calls POST /api/sessions.

Show join code in a modal dialog (blocking overlay) with:

code

expiry countdown

“Cancel session” optional

Subscribe to websocket room using participant credentials.

On websocket event dual_partner_joined, auto-dismiss modal.

B) Phone B join flow

Show a “Join Dual Phone Session” button on the landing screen.

Clicking opens join UI (enter code), calls POST /api/sessions/join-dual.

On success, route into session as role B.

C) Phone C denial

If join-dual returns 409 SESSION_FULL, show a clear message:
“This Dual session already has two devices connected. Start a new session instead.”

Provide CTA: “Start New Session”.

D) Phone A resume on rescan

On /t/{table_token} page load:

Read participant_token from sessionStorage (not localStorage).

Call POST /api/sessions/resume-by-qr with table_token + participant_token.

If it returns an active session and role A, redirect immediately to that session route.

If no token match, show normal start/join options.

SessionStorage keys

participant_token

participant_id

session_id

role

Output

Updated components, modal, API client methods

Error handling states and copy

Acceptance criteria

Phone A rescan resumes instantly only if it has the participant token.

Phone C cannot join, and is offered a safe alternative.

Phase 6 prompt, expiry and cleanup tune-up for dual waiting

Prompt to AI tool
Tune cleanup logic so “waiting” dual sessions do not linger and degrade table usability.

Implement

If dual_status=waiting and pairing_expires_at has passed, end or delete session.

Keep your 24h hard delete policy.

Update last_activity_at on key actions (question viewed, next click, both_ready, etc.).

Ensure cleanup is idempotent.

Acceptance criteria

No long-lived waiting sessions.

Paired sessions remain stable until complete or hard-expire.

Phase 7 prompt, regression testing and rollout controls

Prompt to AI tool
Add a feature flag and produce a QA pack.

Implement

Feature flag: DUAL_PAIRING_MODAL_V2

QA checklist covering:

A creates dual, modal shows code, B joins, modal dismisses

C denied after pair

A disconnects, rescans QR, resumes immediately

Strangers scanning QR cannot resume as A

Socket authorization rejects non-participants

Monitoring signals:

join success rate

SESSION_FULL rate

average time-to-pair

resume success rate for A

Acceptance criteria

We can toggle the feature off if needed.

Tests cover the new behaviors.